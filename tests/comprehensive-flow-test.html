<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç·åˆãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ - æ·±å €ãã‚“v2.0</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f2f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .test-title {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .scenario {
            background: #ecf0f1;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 10px 0;
            font-family: monospace;
            border-radius: 4px;
        }
        .step {
            background: #fff;
            border: 1px solid #bdc3c7;
            padding: 10px;
            margin: 8px 0;
            border-radius: 6px;
        }
        .step-title {
            font-weight: bold;
            color: #34495e;
            margin-bottom: 5px;
        }
        .result-pass { background: #d4edda; border-color: #c3e6cb; color: #155724; }
        .result-fail { background: #f8d7da; border-color: #f5c6cb; color: #721c24; }
        .result-running { background: #fff3cd; border-color: #ffeaa7; color: #856404; }
        .button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
        }
        .button:hover { background: #2980b9; }
        .button.success { background: #27ae60; }
        .button.success:hover { background: #229954; }
        .button.danger { background: #e74c3c; }
        .button.danger:hover { background: #c0392b; }
        .data-display {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 10px 0;
            overflow-x: auto;
        }
        .highlight { background: #f39c12; color: white; padding: 2px 4px; border-radius: 3px; }
    </style>
</head>
<body>
    <h1>ğŸ”¬ ç·åˆãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ</h1>
    <p>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ–‡å­—èµ·ã“ã—ç·¨é›†ã®å®Œå…¨ãƒ•ãƒ­ãƒ¼ã‚’æ¤œè¨¼ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å ±å‘Šå•é¡Œã®è§£æ±ºã‚’ç¢ºèªã—ã¾ã™ã€‚</p>

    <!-- å•é¡Œã®å†ç¾ã‚·ãƒŠãƒªã‚ª -->
    <div class="test-container">
        <div class="test-title">ğŸ› å•é¡Œå†ç¾ã‚·ãƒŠãƒªã‚ª</div>
        <div class="scenario">
            <strong>ãƒ¦ãƒ¼ã‚¶ãƒ¼å ±å‘Šå•é¡Œ:</strong><br>
            1. å½“åˆèªè­˜ï¼šã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã ãœã€<br>
            2. æ‰‹å‹•ä¿®æ­£å¾Œï¼šã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€<br>
            3. éŸ³å£°èªè­˜è¿½åŠ ï¼šã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã ãœã€€AIãã‚“ã€â† å…ƒã«æˆ»ã‚‹<br>
            4. ã€Œã©ã†ãã€èªè­˜æ™‚ï¼šã€ŒãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã ãœã€â† ç·¨é›†ãŒç„¡åŠ¹åŒ–
        </div>
        <button class="button" onclick="reproduceOriginalProblem()">å…ƒã®å•é¡Œã‚’å†ç¾</button>
        <button class="button success" onclick="testFixedBehavior()">ä¿®æ­£å¾Œã®å‹•ä½œãƒ†ã‚¹ãƒˆ</button>
    </div>

    <!-- ãƒ•ãƒ­ãƒ¼ã‚¹ãƒ†ãƒƒãƒ—è¡¨ç¤º -->
    <div class="test-container">
        <div class="test-title">ğŸ“‹ ãƒ†ã‚¹ãƒˆãƒ•ãƒ­ãƒ¼</div>
        <div id="flow-steps"></div>
    </div>

    <!-- ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚° -->
    <div class="test-container">
        <div class="test-title">ğŸ“Š ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°</div>
        <div id="data-monitor" class="data-display">åˆæœŸåŒ–ä¸­...</div>
        <button class="button" onclick="updateDataMonitor()">çŠ¶æ…‹æ›´æ–°</button>
        <button class="button" onclick="startRealtimeMonitoring()">ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹</button>
        <button class="button danger" onclick="stopRealtimeMonitoring()">ç›£è¦–åœæ­¢</button>
    </div>

    <!-- ãƒ†ã‚¹ãƒˆçµæœ -->
    <div class="test-container">
        <div class="test-title">ğŸ“ˆ ãƒ†ã‚¹ãƒˆçµæœ</div>
        <div id="test-results"></div>
    </div>

    <!-- ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ« -->
    <div class="test-container">
        <div class="test-title">ğŸ”§ ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ«</div>
        <div id="debug-console" class="data-display" style="height: 200px; overflow-y: auto;"></div>
        <button class="button" onclick="clearDebugConsole()">ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¯ãƒªã‚¢</button>
        <button class="button danger" onclick="emergencyRollback()">ç·Šæ€¥ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯</button>
    </div>

    <script>
        // =================================================================================
        // ç·åˆãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ 
        // =================================================================================

        let monitoringInterval = null;
        let testResults = {};

        /**
         * ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°æ©Ÿèƒ½
         */
        function debugLog(message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            const console = document.getElementById('debug-console');
            const currentContent = console.innerHTML;
            const newContent = currentContent + '\n' + logEntry;
            
            if (data) {
                console.innerHTML = newContent + '\n    â†’ ' + JSON.stringify(data, null, 2);
            } else {
                console.innerHTML = newContent;
            }
            
            console.scrollTop = console.scrollHeight;
            window.console.log(message, data || '');
        }

        /**
         * ãƒ‡ãƒ¼ã‚¿çŠ¶æ…‹ç›£è¦–æ›´æ–°
         */
        function updateDataMonitor() {
            const monitor = document.getElementById('data-monitor');
            
            const state = {
                timestamp: new Date().toISOString(),
                AppState: {
                    currentTranscript: window.AppState?.currentTranscript || '',
                    transcriptHistory: window.AppState?.transcriptHistory || [],
                    transcriptHistoryLength: window.AppState?.transcriptHistory?.length || 0
                },
                editManager: {
                    exists: !!window.transcriptEditManager,
                    isEditing: window.transcriptEditManager?.isEditing || false,
                    originalText: window.transcriptEditManager?.originalText || ''
                },
                protectionStatus: window.TranscriptProtectionManager?.getProtectionStatus() || null,
                stateController: {
                    exists: !!window.StateUpdateController,
                    debugLogsCount: window.StateUpdateController?.debugLogs?.length || 0
                }
            };
            
            monitor.textContent = JSON.stringify(state, null, 2);
        }

        /**
         * ãƒ•ãƒ­ãƒ¼ã‚¹ãƒ†ãƒƒãƒ—è¡¨ç¤ºæ›´æ–°
         */
        function updateFlowSteps(steps) {
            const container = document.getElementById('flow-steps');
            container.innerHTML = '';
            
            steps.forEach((step, index) => {
                const stepDiv = document.createElement('div');
                stepDiv.className = `step ${step.status}`;
                
                const statusEmoji = {
                    'result-pass': 'âœ…',
                    'result-fail': 'âŒ',
                    'result-running': 'â³'
                }[step.status] || 'ğŸ“‹';
                
                stepDiv.innerHTML = `
                    <div class="step-title">${statusEmoji} Step ${index + 1}: ${step.title}</div>
                    <div>${step.description}</div>
                    ${step.data ? `<div class="data-display">${JSON.stringify(step.data, null, 2)}</div>` : ''}
                `;
                
                container.appendChild(stepDiv);
            });
        }

        /**
         * å…ƒã®å•é¡Œã‚’å†ç¾
         */
        async function reproduceOriginalProblem() {
            debugLog('ğŸ› å…ƒã®å•é¡Œå†ç¾é–‹å§‹');
            
            const steps = [
                { title: 'åˆæœŸçŠ¶æ…‹è¨­å®š', description: 'éŸ³å£°èªè­˜çµæœã‚’è¨­å®š', status: 'result-running' },
                { title: 'æ‰‹å‹•ç·¨é›†å®Ÿè¡Œ', description: 'ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹æ‰‹å‹•ä¿®æ­£', status: 'result-running' },
                { title: 'éŸ³å£°èªè­˜è¿½åŠ ', description: 'æ–°ã—ã„éŸ³å£°èªè­˜çµæœã®è¿½åŠ ', status: 'result-running' },
                { title: 'ã€Œã©ã†ãã€å‡¦ç†', description: 'ãƒ‡ãƒ¼ã‚¿å–å¾—ã¨å‡¦ç†å®Ÿè¡Œ', status: 'result-running' }
            ];
            
            updateFlowSteps(steps);
            
            try {
                // Step 1: åˆæœŸçŠ¶æ…‹è¨­å®š
                if (!window.AppState) {
                    window.AppState = { currentTranscript: '', transcriptHistory: [] };
                }
                
                const originalText = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã ãœ';
                window.AppState.currentTranscript = originalText;
                window.AppState.transcriptHistory = [originalText];
                
                steps[0].status = 'result-pass';
                steps[0].data = { currentTranscript: originalText, transcriptHistory: [originalText] };
                updateFlowSteps(steps);
                debugLog('Step 1å®Œäº†: åˆæœŸçŠ¶æ…‹è¨­å®š', { originalText });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 2: æ‰‹å‹•ç·¨é›†ï¼ˆå¾“æ¥ã®å•é¡Œã®ã‚ã‚‹æ–¹æ³•ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆï¼‰
                const editedText = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™';
                
                // ğŸ› å•é¡Œå†ç¾: currentTranscriptã®ã¿æ›´æ–°ã€transcriptHistoryã¯æ›´æ–°ã—ãªã„
                window.AppState.currentTranscript = editedText;
                // transcriptHistoryã¯æ„å›³çš„ã«æ›´æ–°ã—ãªã„ï¼ˆå•é¡Œã‚’å†ç¾ï¼‰
                
                steps[1].status = 'result-pass';
                steps[1].data = { 
                    currentTranscript: editedText, 
                    transcriptHistory: window.AppState.transcriptHistory,
                    note: 'âš ï¸ transcriptHistoryãŒæœªæ›´æ–°ï¼ˆå•é¡Œå†ç¾ï¼‰'
                };
                updateFlowSteps(steps);
                debugLog('Step 2å®Œäº†: æ‰‹å‹•ç·¨é›†ï¼ˆå•é¡Œå†ç¾ç‰ˆï¼‰', { editedText });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 3: éŸ³å£°èªè­˜è¿½åŠ 
                const additionalText = 'AIãã‚“';
                window.AppState.transcriptHistory.push(additionalText);
                const combinedText = window.AppState.transcriptHistory.join(' ');
                window.AppState.currentTranscript = combinedText;
                
                steps[2].status = 'result-pass';
                steps[2].data = { 
                    additionalText,
                    combinedText,
                    note: 'ç·¨é›†å†…å®¹ãŒæ¶ˆå¤±ã—ã¦ã„ã‚‹'
                };
                updateFlowSteps(steps);
                debugLog('Step 3å®Œäº†: éŸ³å£°èªè­˜è¿½åŠ ', { combinedText });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 4: ã€Œã©ã†ãã€å‡¦ç†ï¼ˆå¾“æ¥ã®å•é¡Œã®ã‚ã‚‹æ–¹æ³•ï¼‰
                const transcriptHistoryText = window.AppState.transcriptHistory.join(' ');
                
                steps[3].status = 'result-fail';
                steps[3].data = { 
                    processedText: transcriptHistoryText,
                    expectedText: editedText + ' ' + additionalText,
                    note: 'âŒ ç·¨é›†å†…å®¹ãŒåæ˜ ã•ã‚Œã¦ã„ãªã„'
                };
                updateFlowSteps(steps);
                debugLog('Step 4å®Œäº†: ã€Œã©ã†ãã€å‡¦ç†ï¼ˆå•é¡Œç¢ºèªï¼‰', { 
                    processed: transcriptHistoryText,
                    expected: editedText + ' ' + additionalText
                });
                
                testResults['å•é¡Œå†ç¾ãƒ†ã‚¹ãƒˆ'] = { 
                    passed: false, 
                    message: 'å…ƒã®å•é¡ŒãŒæ­£å¸¸ã«å†ç¾ã•ã‚Œã¾ã—ãŸ' 
                };
                
                debugLog('ğŸ› å…ƒã®å•é¡Œå†ç¾å®Œäº† - ç·¨é›†å†…å®¹ãŒå¤±ã‚ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª');
                
            } catch (error) {
                debugLog('âŒ å•é¡Œå†ç¾ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error.message);
                steps[steps.length - 1].status = 'result-fail';
                updateFlowSteps(steps);
            }
            
            updateTestResults();
        }

        /**
         * ä¿®æ­£å¾Œã®å‹•ä½œãƒ†ã‚¹ãƒˆ
         */
        async function testFixedBehavior() {
            debugLog('âœ… ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const steps = [
                { title: 'åˆæœŸçŠ¶æ…‹è¨­å®š', description: 'éŸ³å£°èªè­˜çµæœã‚’è¨­å®š', status: 'result-running' },
                { title: 'Phase 1ä¿®æ­£ç‰ˆç·¨é›†', description: 'å®Œå…¨åŒæœŸã«ã‚ˆã‚‹æ‰‹å‹•ä¿®æ­£', status: 'result-running' },
                { title: 'éŸ³å£°èªè­˜è¿½åŠ ', description: 'ä¿è­·æ©Ÿèƒ½ã«ã‚ˆã‚‹å®‰å…¨ãªè¿½åŠ ', status: 'result-running' },
                { title: 'Phase 2ä¿®æ­£ç‰ˆã€Œã©ã†ãã€', description: 'currentTranscriptå„ªå…ˆãƒ‡ãƒ¼ã‚¿å–å¾—', status: 'result-running' }
            ];
            
            updateFlowSteps(steps);
            
            try {
                // Step 1: åˆæœŸçŠ¶æ…‹è¨­å®š
                if (!window.AppState) {
                    window.AppState = { currentTranscript: '', transcriptHistory: [] };
                }
                
                const originalText = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã ãœ';
                window.AppState.currentTranscript = originalText;
                window.AppState.transcriptHistory = [originalText];
                
                steps[0].status = 'result-pass';
                steps[0].data = { currentTranscript: originalText, transcriptHistory: [originalText] };
                updateFlowSteps(steps);
                debugLog('Step 1å®Œäº†: åˆæœŸçŠ¶æ…‹è¨­å®š', { originalText });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 2: Phase 1ä¿®æ­£ç‰ˆç·¨é›†ï¼ˆå®Œå…¨åŒæœŸï¼‰
                const editedText = 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™';
                
                // ğŸ¯ Phase 1ä¿®æ­£: StateUpdateControllerã«ã‚ˆã‚‹å®Œå…¨åŒæœŸ
                if (window.StateUpdateController) {
                    window.StateUpdateController.atomicStateUpdate('edit', {
                        'AppState': () => {
                            window.AppState.currentTranscript = editedText;
                            window.AppState.transcriptHistory = [editedText]; // ğŸ”§ é‡è¦: åŒæ™‚æ›´æ–°
                        }
                    });
                } else {
                    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ‰‹å‹•ã§åŒæœŸ
                    window.AppState.currentTranscript = editedText;
                    window.AppState.transcriptHistory = [editedText];
                }
                
                steps[1].status = 'result-pass';
                steps[1].data = { 
                    currentTranscript: editedText, 
                    transcriptHistory: window.AppState.transcriptHistory,
                    note: 'âœ… currentTranscriptã¨transcriptHistoryãŒåŒæœŸã•ã‚Œã¦ã„ã‚‹'
                };
                updateFlowSteps(steps);
                debugLog('Step 2å®Œäº†: Phase 1ä¿®æ­£ç‰ˆç·¨é›†', { 
                    currentTranscript: window.AppState.currentTranscript,
                    transcriptHistory: window.AppState.transcriptHistory
                });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 3: éŸ³å£°èªè­˜è¿½åŠ 
                const additionalText = 'AIãã‚“';
                window.AppState.transcriptHistory.push(additionalText);
                const combinedText = window.AppState.transcriptHistory.join(' ');
                window.AppState.currentTranscript = combinedText;
                
                steps[2].status = 'result-pass';
                steps[2].data = { 
                    additionalText,
                    combinedText,
                    note: 'ç·¨é›†å†…å®¹ãŒä¿æŒã•ã‚Œã¦ã„ã‚‹'
                };
                updateFlowSteps(steps);
                debugLog('Step 3å®Œäº†: éŸ³å£°èªè­˜è¿½åŠ ', { combinedText });
                
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Step 4: Phase 2ä¿®æ­£ç‰ˆã€Œã©ã†ãã€å‡¦ç†
                let processedText;
                
                // ğŸ¯ Phase 2ä¿®æ­£: currentTranscriptã‚’å„ªå…ˆä½¿ç”¨
                if (window.AppState.currentTranscript && window.AppState.currentTranscript.trim()) {
                    processedText = window.AppState.currentTranscript.trim();
                } else {
                    processedText = window.AppState.transcriptHistory.join(' ').trim();
                }
                
                const expectedText = editedText + ' ' + additionalText;
                const isFixed = processedText === expectedText;
                
                steps[3].status = isFixed ? 'result-pass' : 'result-fail';
                steps[3].data = { 
                    processedText,
                    expectedText,
                    isFixed,
                    note: isFixed ? 'âœ… ç·¨é›†å†…å®¹ãŒæ­£ã—ãåæ˜ ã•ã‚Œã¦ã„ã‚‹' : 'âŒ ã¾ã å•é¡ŒãŒæ®‹ã£ã¦ã„ã‚‹'
                };
                updateFlowSteps(steps);
                debugLog('Step 4å®Œäº†: Phase 2ä¿®æ­£ç‰ˆã€Œã©ã†ãã€å‡¦ç†', { 
                    processed: processedText,
                    expected: expectedText,
                    fixed: isFixed
                });
                
                testResults['ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆ'] = { 
                    passed: isFixed, 
                    message: isFixed ? 'å•é¡ŒãŒå®Œå…¨ã«ä¿®æ­£ã•ã‚Œã¾ã—ãŸï¼' : 'ä¿®æ­£ãŒä¸å®Œå…¨ã§ã™'
                };
                
                if (isFixed) {
                    debugLog('ğŸ‰ ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆæˆåŠŸ - å•é¡ŒãŒè§£æ±ºã•ã‚Œã¾ã—ãŸï¼');
                } else {
                    debugLog('âš ï¸ ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆå¤±æ•— - è¿½åŠ ä¿®æ­£ãŒå¿…è¦ã§ã™');
                }
                
            } catch (error) {
                debugLog('âŒ ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:', error.message);
                steps[steps.length - 1].status = 'result-fail';
                updateFlowSteps(steps);
            }
            
            updateTestResults();
        }

        /**
         * ãƒ†ã‚¹ãƒˆçµæœè¡¨ç¤ºæ›´æ–°
         */
        function updateTestResults() {
            const resultsDiv = document.getElementById('test-results');
            let html = '';
            
            Object.entries(testResults).forEach(([testName, result]) => {
                const statusClass = result.passed ? 'result-pass' : 'result-fail';
                const statusEmoji = result.passed ? 'âœ…' : 'âŒ';
                
                html += `
                    <div class="step ${statusClass}">
                        <div class="step-title">${statusEmoji} ${testName}</div>
                        <div>${result.message}</div>
                    </div>
                `;
            });
            
            if (html === '') {
                html = '<div class="step">ãƒ†ã‚¹ãƒˆæœªå®Ÿè¡Œ</div>';
            }
            
            resultsDiv.innerHTML = html;
        }

        /**
         * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹
         */
        function startRealtimeMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
            }
            
            monitoringInterval = setInterval(updateDataMonitor, 1000);
            debugLog('ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–é–‹å§‹');
        }

        /**
         * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–åœæ­¢
         */
        function stopRealtimeMonitoring() {
            if (monitoringInterval) {
                clearInterval(monitoringInterval);
                monitoringInterval = null;
                debugLog('ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–åœæ­¢');
            }
        }

        /**
         * ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¯ãƒªã‚¢
         */
        function clearDebugConsole() {
            document.getElementById('debug-console').innerHTML = '';
        }

        /**
         * ç·Šæ€¥ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯
         */
        function emergencyRollback() {
            if (window.emergencyRollback) {
                window.emergencyRollback();
                debugLog('ğŸš¨ ç·Šæ€¥ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œ');
                updateDataMonitor();
            } else {
                debugLog('âŒ ç·Šæ€¥ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
            }
        }

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('ğŸ”¬ ç·åˆãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
            updateDataMonitor();
            updateTestResults();
            
            // 3ç§’å¾Œã«è‡ªå‹•ãƒ†ã‚¹ãƒˆé–‹å§‹
            setTimeout(() => {
                debugLog('â° è‡ªå‹•ãƒ†ã‚¹ãƒˆé–‹å§‹ - ã¾ãšå•é¡Œã‚’å†ç¾ã—ã¾ã™');
                reproduceOriginalProblem().then(() => {
                    setTimeout(() => {
                        debugLog('â° ä¿®æ­£å¾Œå‹•ä½œãƒ†ã‚¹ãƒˆã‚’é–‹å§‹ã—ã¾ã™');
                        testFixedBehavior();
                    }, 3000);
                });
            }, 3000);
        });
    </script>
</body>
</html> 